name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      release_branch:
        description: 'Release branch name (e.g., release/v1.0.0)'
        required: true
        type: string
      confirm:
        description: 'Type "deploy" to confirm production deployment'
        required: true
        type: string

permissions:
  contents: write
  deployments: write
  packages: write

jobs:
  validate:
    name: Validate inputs
    runs-on: ubuntu-latest
    steps:
      - name: Validate confirmation
        if: inputs.confirm != 'deploy'
        run: |
          echo "::error::Deployment not confirmed." \
               "Please type 'deploy' in the confirm field."
          exit 1

      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_branch }}
          fetch-depth: 0

      - name: Validate release branch exists
        run: |
          BRANCH="${{ inputs.release_branch }}"
          if ! git rev-parse --verify "$BRANCH" >/dev/null 2>&1; then
            echo "::error::Release branch '$BRANCH' does not exist"
            exit 1
          fi

  detect-changes:
    name: Detect changed services
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      products: ${{ steps.filter.outputs.products }}
      content: ${{ steps.filter.outputs.content }}
      gateway: ${{ steps.filter.outputs.gateway }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_branch }}
          fetch-depth: 0

      - name: Determine comparison base
        id: base
        run: |
          # Find the most recent production tag
          LAST_TAG=$(git tag -l '@apollo-bff-test/*@*' --sort=-version:refname | head -n1)

          if [ -z "$LAST_TAG" ]; then
            # No tags = initial release, compare against main
            git fetch origin main:main
            echo "base=main" >> "$GITHUB_OUTPUT"
            echo "::notice::Initial release detected - comparing against main"
          else
            # Extract commit from last tag
            LAST_COMMIT=$(git rev-list -n 1 "$LAST_TAG")
            echo "base=$LAST_COMMIT" >> "$GITHUB_OUTPUT"
            echo "::notice::Comparing against last production release: $LAST_TAG ($LAST_COMMIT)"
          fi

      - uses: dorny/paths-filter@v3
        id: filter
        with:
          base: ${{ steps.base.outputs.base }}
          ref: ${{ inputs.release_branch }}
          filters: |
            products:
              - "apps/subgraphs/products/**"
              - "packages/**"
            content:
              - "apps/subgraphs/content/**"
              - "packages/**"
            gateway:
              - "apps/gateway/**"
              - "packages/**"

      - name: Show detected changes
        run: |
          echo "Comparison base: ${{ steps.base.outputs.base }}"
          echo "Detected changes in release branch:"
          echo "Products: ${{ steps.filter.outputs.products }}"
          echo "Content: ${{ steps.filter.outputs.content }}"
          echo "Gateway: ${{ steps.filter.outputs.gateway }}"

  build-products:
    name: Build products
    needs: detect-changes
    if: needs.detect-changes.outputs.products == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}
      version: ${{ steps.app-version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_branch }}

      - name: Read service version
        id: app-version
        run: |
          VERSION=$(jq -r '.version' \
            "apps/subgraphs/products/package.json")
          if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
            echo "::error::Failed to read version from" \
                 "apps/subgraphs/products/package.json"
            exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Products version: $VERSION"

      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        env:
          VERSION: ${{ steps.app-version.outputs.version }}
        with:
          images: ghcr.io/${{ github.repository }}/products
          tags: |
            type=sha,prefix=,format=long
            type=semver,pattern={{version}},value=${{ env.VERSION }}
            type=semver,pattern={{major}}.{{minor}},value=${{ env.VERSION }}
            type=semver,pattern={{major}},value=${{ env.VERSION }}

      - uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/subgraphs/products/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image tag output
        id: image-tag
        env:
          REPO: ${{ github.repository }}
          VERSION: ${{ steps.app-version.outputs.version }}
        run: echo "tag=ghcr.io/$REPO/products:$VERSION" >> "$GITHUB_OUTPUT"

  build-content:
    name: Build content
    needs: detect-changes
    if: needs.detect-changes.outputs.content == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}
      version: ${{ steps.app-version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_branch }}

      - name: Read service version
        id: app-version
        run: |
          VERSION=$(jq -r '.version' \
            "apps/subgraphs/content/package.json")
          if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
            echo "::error::Failed to read version from" \
                 "apps/subgraphs/content/package.json"
            exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Content version: $VERSION"

      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        env:
          VERSION: ${{ steps.app-version.outputs.version }}
        with:
          images: ghcr.io/${{ github.repository }}/content
          tags: |
            type=sha,prefix=,format=long
            type=semver,pattern={{version}},value=${{ env.VERSION }}
            type=semver,pattern={{major}}.{{minor}},value=${{ env.VERSION }}
            type=semver,pattern={{major}},value=${{ env.VERSION }}

      - uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/subgraphs/content/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image tag output
        id: image-tag
        env:
          REPO: ${{ github.repository }}
          VERSION: ${{ steps.app-version.outputs.version }}
        run: echo "tag=ghcr.io/$REPO/content:$VERSION" >> "$GITHUB_OUTPUT"

  build-gateway:
    name: Build gateway
    needs: detect-changes
    if: needs.detect-changes.outputs.gateway == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.image-tag.outputs.tag }}
      version: ${{ steps.app-version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_branch }}

      - name: Read service version
        id: app-version
        run: |
          VERSION=$(jq -r '.version' "apps/gateway/package.json")
          if [ -z "$VERSION" ] || [ "$VERSION" = "null" ]; then
            echo "::error::Failed to read version from" \
                 "apps/gateway/package.json"
            exit 1
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Gateway version: $VERSION"

      - uses: docker/setup-buildx-action@v3
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        env:
          VERSION: ${{ steps.app-version.outputs.version }}
        with:
          images: ghcr.io/${{ github.repository }}/gateway
          tags: |
            type=sha,prefix=,format=long
            type=semver,pattern={{version}},value=${{ env.VERSION }}
            type=semver,pattern={{major}}.{{minor}},value=${{ env.VERSION }}
            type=semver,pattern={{major}},value=${{ env.VERSION }}

      - uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/gateway/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image tag output
        id: image-tag
        env:
          REPO: ${{ github.repository }}
          VERSION: ${{ steps.app-version.outputs.version }}
        run: echo "tag=ghcr.io/$REPO/gateway:$VERSION" >> "$GITHUB_OUTPUT"

  deploy-products:
    name: Deploy products to production
    needs: [detect-changes, build-products]
    if: needs.detect-changes.outputs.products == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: products-prod
      image: ${{ needs.build-products.outputs.image_tag }}
      publish_schema: true
      subgraph_name: products
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      APOLLO_KEY: ${{ secrets.APOLLO_KEY }}
      APOLLO_GRAPH_REF: ${{ secrets.APOLLO_GRAPH_REF }}
      APOLLO_ROUTING_URL: ${{ secrets.APOLLO_ROUTING_URL }}

  deploy-content:
    name: Deploy content to production
    needs: [detect-changes, build-content]
    if: needs.detect-changes.outputs.content == 'true'
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: content-prod
      image: ${{ needs.build-content.outputs.image_tag }}
      publish_schema: true
      subgraph_name: content
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      APOLLO_KEY: ${{ secrets.APOLLO_KEY }}
      APOLLO_GRAPH_REF: ${{ secrets.APOLLO_GRAPH_REF }}
      APOLLO_ROUTING_URL: ${{ secrets.APOLLO_ROUTING_URL }}

  deploy-gateway:
    name: Deploy gateway to production
    needs:
      - detect-changes
      - build-gateway
      - deploy-products
      - deploy-content
    if: |
      always() &&
      needs.detect-changes.outputs.gateway == 'true' &&
      (needs.deploy-products.result == 'success' ||
       needs.deploy-products.result == 'skipped') &&
      (needs.deploy-content.result == 'success' ||
       needs.deploy-content.result == 'skipped')
    uses: ./.github/workflows/_deploy-render.yaml
    with:
      app: gateway-prod
      image: ${{ needs.build-gateway.outputs.image_tag }}
    secrets:
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}

  create-tags:
    name: Create git tags
    needs:
      - detect-changes
      - build-products
      - build-content
      - build-gateway
      - deploy-products
      - deploy-content
      - deploy-gateway
    if: |
      always() &&
      (needs.deploy-products.result == 'success' ||
       needs.deploy-content.result == 'success' ||
       needs.deploy-gateway.result == 'success')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_branch }}
          fetch-depth: 0

      - name: Create git tags for deployed services
        env:
          PRODUCTS_RESULT: ${{ needs.deploy-products.result }}
          PRODUCTS_VERSION: ${{ needs.build-products.outputs.version }}
          CONTENT_RESULT: ${{ needs.deploy-content.result }}
          CONTENT_VERSION: ${{ needs.build-content.outputs.version }}
          GATEWAY_RESULT: ${{ needs.deploy-gateway.result }}
          GATEWAY_VERSION: ${{ needs.build-gateway.outputs.version }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email \
               "github-actions[bot]@users.noreply.github.com"

          BRANCH="${{ inputs.release_branch }}"
          SERVICES=("products" "content" "gateway")

          for SERVICE in "${SERVICES[@]}"; do
            SERVICE_UPPER=$(echo "$SERVICE" | tr '[:lower:]' '[:upper:]')
            RESULT_VAR="${SERVICE_UPPER}_RESULT"
            VERSION_VAR="${SERVICE_UPPER}_VERSION"

            RESULT="${!RESULT_VAR}"
            VERSION="${!VERSION_VAR}"

            if [ "$RESULT" = "success" ] && [ -n "$VERSION" ]; then
              TAG="@apollo-bff-test/${SERVICE}@${VERSION}"
              if ! git rev-parse "$TAG" >/dev/null 2>&1; then
                git tag -a "$TAG" -m "Release $TAG from $BRANCH"
                git push origin "$TAG"
                echo "Created tag: $TAG"
              else
                echo "Tag already exists: $TAG"
              fi
            fi
          done
